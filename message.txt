/*
 * HelTec Automation(TM) CubeCell software serial example
 *
 * Function summary:
 * 
 * - software read data from a UART device and print received data via normal serial prot
 * - baudrate defined in Serial2.begin(9600);
 * |-- Supported baudrate
 * |-- 57600
 * |-- 38400
 * |-- 19200
 * |-- 14400
 * |-- 9600
 * |-- 4800
 * |-- 2400
 * |-- 1200
 *
 * HelTec AutoMation, Chengdu, China.
 * 成都惠利特自动化科技有限公司
 * https://heltec.org
 * support@heltec.cn
 *
 * this project also release in GitHub:
 * 
 */

#include "softSerial.h"
// #include <stdlib.h>




void setup()
{
	//serial init
  Serial.begin(9600);
	Serial.println("Normal serial init");
  softSerial Serial3 = mySERCOM(GPIO4, GPIO5, 9600);
  Serial.println(Serial3.write("P"));
}

void loop(){
  Serial.println("**********Serial Loop**********");
  //delay(10);
  delay(2000);
  Serial.println("Rain = " + read_rain());
  delay(2000);
  Serial.println("Dist = " + String(read_distance()));
}

void clear_serial(softSerial ser_COM){
  ser_COM.flush();
  delay(100);
}

String read_rain() {
    softSerial Serial3 = mySERCOM(GPIO4, GPIO5, 9600);
    
    String inByte = "";
    //Serial.println(Serial1.println("R"));
    int curr_delay = 0;
    while(!Serial3.available() && curr_delay < 5){
        if(curr_delay != 0){
            Serial3.println("R");
        }
        delay(100);
        curr_delay++;
    }
    if (Serial3.available()) {
      Serial.println("Reading Rain");
      inByte = Serial3.readString();
    }
    Serial3.flush();
    return inByte;
}

uint16_t read_distance() {
    char buffer_RTT[4] = {0};
    uint16_t distance = 0;
    int attempts = 0;

    //RE-INIT Serial2 for Distance
    softSerial Serial2 = mySERCOM(GPIO1, GPIO2, 9600);
    uint8_t TRIGGER_PIN = GPIO3;
   
    while(!Serial2.available()){
        delay(100);
    }
    if (Serial2.available()) {

    for(int attempts = 0; attempts < 5; attempts++){
        clear_serial(Serial2);

        //TRIGGER_PIN needs to be pulled high for a minimum of 20 microseconds.
        digitalWrite(TRIGGER_PIN, HIGH);
        delayMicroseconds(20);            
        digitalWrite(TRIGGER_PIN, LOW);
        delay(100);

        if (Serial2.available() > 0) {
            do {
                if (Serial2.read() == 'R') {
                    for (int i = 0; i < 4; i++) {
                        buffer_RTT[i] = Serial2.read();
                    }
                }
            } while (buffer_RTT == NULL);
            distance = (buffer_RTT[0] - '0') * 1000 + (buffer_RTT[1] - '0') * 100 + (buffer_RTT[2] - '0') * 10 + (buffer_RTT[3] - '0');
            if(distance >= 300 && distance <= 5000){
                Serial2.flush();
                return distance;
            }
        }
        delay(100);
    }
    return 0;
  }
}

softSerial mySERCOM(uint8_t tx_GPIO, uint8_t rx_GPIO, int sr_BAUD)
{
  softSerial SerialCOM(tx_GPIO /*TX pin*/, rx_GPIO /*RX pin*/);
  SerialCOM.begin(sr_BAUD);
  return SerialCOM;
}